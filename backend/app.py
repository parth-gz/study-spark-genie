from flask import Flask, request, jsonify
from flask_cors import CORS
import os
import google.generativeai as genai
import PyPDF2

app = Flask(__name__)
CORS(app, resources={r"/api/*": {"origins": "*"}})  # Enable CORS for all routes with more specific configuration

# Initialize Gemini API with your API key
# Replace this with your actual API key or set it as an environment variable
gemini_api_key = "abcd"  # You mentioned you would replace this with your key
genai.configure(api_key=gemini_api_key)

@app.route('/api/chat', methods=['POST'])
def chat():
    """
    Process a chat message and return an AI response using Gemini
    """
    print("Received chat request")
    data = request.json
    user_message = data.get('message', '')
    settings = data.get('settings', {})
    
    print(f"Processing message: {user_message}")
    
    # Process with Gemini API
    response = get_gemini_response(user_message, settings)
    print(f"Generated response: {response}")
    
    return jsonify(response)

@app.route('/api/upload', methods=['POST'])
def upload_pdf():
    """
    Handle PDF uploads and process them for RAG
    """
    if 'file' not in request.files:
        return jsonify({'error': 'No file part'}), 400
        
    file = request.files['file']
    
    if file.filename == '':
        return jsonify({'error': 'No selected file'}), 400
        
    if file and file.filename.endswith('.pdf'):
        # Save file temporarily
        filename = file.filename
        file_path = os.path.join('temp_uploads', filename)
        os.makedirs('temp_uploads', exist_ok=True)
        file.save(file_path)
        
        # Extract text from PDF
        pdf_text = extract_text_from_pdf(file_path)
        pdf_id = f"pdf-{os.urandom(4).hex()}"
        
        # In a real implementation, you would store this text for RAG
        
        return jsonify({
            'id': pdf_id,
            'name': filename,
            'size': os.path.getsize(file_path),
            'lastModified': os.path.getmtime(file_path)
        })
    
    return jsonify({'error': 'File must be a PDF'}), 400

@app.route('/api/export', methods=['POST'])
def export_conversation():
    """
    Export a conversation to a file
    """
    data = request.json
    messages = data.get('messages', [])
    
    # In a real implementation, this would generate a PDF or other format
    # For now, we'll just acknowledge the request
    return jsonify({'success': True, 'message': 'Export successful'})

def get_gemini_response(question, settings):
    response_id = f'ai-{os.urandom(4).hex()}'

    try:
        # Build system instruction
        system_instruction = "You are a helpful study assistant that provides accurate, educational responses."
        if settings.get('simplifiedAnswers', False):
            system_instruction += " Provide simplified explanations suitable for beginners."
        if settings.get('stepByStepSolutions', True):
            system_instruction += " Break down complex concepts into clear step-by-step explanations."

        # Configure the Gemini model with system instruction
        model = genai.GenerativeModel(
            model_name='gemini-1.5-pro-latest',
            system_instruction=system_instruction
        )

        # Start chat session without system role in history
        chat = model.start_chat(history=[])

        # Send user's message
        gemini_response = chat.send_message(question)

        content = gemini_response.text

        response = {
            'id': response_id,
            'type': 'ai',
            'content': content,
            'timestamp': '',
        }

        if settings.get('stepByStepSolutions', True):
            steps = extract_steps_from_content(content)
            if steps:
                response['steps'] = steps

        if settings.get('showSources', True):
            response['sources'] = [
                {
                    "title": "Generated by Gemini 1.5 Pro",
                    "url": "https://ai.google.dev/",
                    "description": "AI-generated content"
                }
            ]

        return response

    except Exception as e:
        return {
            'id': response_id,
            'type': 'ai',
            'content': f"I encountered an error while processing your request. Error details: {str(e)}",
            'timestamp': '',
        }

def extract_steps_from_content(content):
    """
    Simple function to try to extract steps from the content
    In a real implementation, you might use a more sophisticated approach
    or directly ask the model to format its response with steps
    """
    lines = content.split('\n')
    steps = []
    
    for line in lines:
        # Look for numbered lines or lines starting with common step indicators
        if (line.strip().startswith(('1.', '2.', '3.', '4.', '5.', 'Step 1', 'Step 2', 'First', 'Second'))):
            # Clean up the step text
            step_text = line.strip().split('.', 1)[-1].strip()
            if step_text and len(steps) < 5:  # Limit to 5 steps
                steps.append(step_text)
    
    return steps

def extract_text_from_pdf(file_path):
    """
    Extract text content from a PDF file
    """
    text = ""
    try:
        with open(file_path, 'rb') as file:
            reader = PyPDF2.PdfReader(file)
            for page_num in range(len(reader.pages)):
                text += reader.pages[page_num].extract_text() + "\n"
    except Exception as e:
        print(f"Error extracting text from PDF: {e}")
    return text

def process_pdf(file_path, filename):
    """
    Process a PDF file to extract text
    """
    pdf_id = f"pdf-{os.urandom(4).hex()}"
    # Extract the text content
    text_content = extract_text_from_pdf(file_path)
    
    # Here we would store the text content for later use with RAG
    # This is a simplified implementation
    
    return pdf_id

if __name__ == '__main__':
    # Run on port 3001 to avoid conflicts with the frontend in development
    print("Starting Flask server on port 3001")
    app.run(debug=True, port=3001, host='0.0.0.0')
